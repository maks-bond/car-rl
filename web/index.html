<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>car-rl viz</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --text: #e5e7eb;
      --track: #1f2937;
      --wall: #ef4444;
      --car: #22d3ee;
      --line: #f59e0b;
      --ok: #34d399;
    }
    body {
      margin: 0;
      font-family: "IBM Plex Sans", "Segoe UI", sans-serif;
      background: radial-gradient(circle at 10% 20%, #1e293b, var(--bg));
      color: var(--text);
      display: grid;
      grid-template-columns: 320px 1fr;
      min-height: 100vh;
    }
    .panel {
      padding: 16px;
      background: rgba(17, 24, 39, 0.92);
      border-right: 1px solid rgba(255, 255, 255, 0.08);
    }
    h1 { margin: 0 0 12px; font-size: 20px; }
    .stat { margin: 8px 0; font-size: 14px; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 14px 0; }
    button {
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: #0b1220;
      color: var(--text);
      padding: 8px 10px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
    }
    button:hover { background: #17223a; }
    canvas { width: 100%; height: 100%; background: var(--track); }
    .viewport { padding: 12px; }
  </style>
</head>
<body>
  <aside class="panel">
    <h1>car-rl simulator</h1>
    <div class="stat" id="status">status: connecting...</div>
    <div class="stat" id="episode">episode: -</div>
    <div class="stat" id="step">step: -</div>
    <div class="stat" id="reward">reward: -</div>
    <div class="stat" id="event">event: -</div>
    <div class="stat" id="mode">mode: -</div>
    <div class="stat" id="speed">speed: -</div>
    <div class="stat" id="steer">steer: -</div>
    <div class="stat" id="pose-ref">pose ref: rear axle center</div>
    <div class="controls">
      <button id="btn-step">Step</button>
      <button id="btn-pause">Pause</button>
      <button id="btn-play">Play</button>
      <button id="btn-play-end">Play To End</button>
    </div>
    <p style="font-size: 13px; opacity: 0.85; line-height: 1.4;">
      Start another terminal:<br />
      <code>PYTHONPATH=src python -m car_rl.apps.run_viz</code>
    </p>
  </aside>
  <main class="viewport">
    <canvas id="sim"></canvas>
  </main>

  <script>
    const canvas = document.getElementById("sim");
    const ctx = canvas.getContext("2d");

    const statusEl = document.getElementById("status");
    const episodeEl = document.getElementById("episode");
    const stepEl = document.getElementById("step");
    const rewardEl = document.getElementById("reward");
    const eventEl = document.getElementById("event");
    const modeEl = document.getElementById("mode");
    const speedEl = document.getElementById("speed");
    const steerEl = document.getElementById("steer");

    let lastFrame = null;
    const defaultMap = {
      walls: [
        { p1: [0, -2], p2: [30, -2] },
        { p1: [0, 2], p2: [30, 2] },
      ],
      start_line: { p1: [0, -2], p2: [0, 2] },
      finish_line: { p1: [30, -2], p2: [30, 2] },
    };

    function resize() {
      canvas.width = canvas.clientWidth * window.devicePixelRatio;
      canvas.height = canvas.clientHeight * window.devicePixelRatio;
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
    }
    window.addEventListener("resize", resize);
    resize();

    function mapBounds(map) {
      const points = [];
      map.walls.forEach((w) => {
        points.push(w.p1, w.p2);
      });
      points.push(map.start_line.p1, map.start_line.p2, map.finish_line.p1, map.finish_line.p2);

      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      points.forEach(([x, y]) => {
        minX = Math.min(minX, x);
        maxX = Math.max(maxX, x);
        minY = Math.min(minY, y);
        maxY = Math.max(maxY, y);
      });
      return { minX, maxX, minY, maxY };
    }

    function makeCamera(map) {
      const padPx = 40;
      const worldMargin = 1.0;
      const minWorldHeight = 14.0;

      const bounds = mapBounds(map);
      let minX = bounds.minX - worldMargin;
      let maxX = bounds.maxX + worldMargin;
      let minY = bounds.minY - worldMargin;
      let maxY = bounds.maxY + worldMargin;

      const width = maxX - minX;
      let height = maxY - minY;
      if (height < minWorldHeight) {
        const extra = (minWorldHeight - height) / 2;
        minY -= extra;
        maxY += extra;
        height = maxY - minY;
      }

      const drawW = Math.max(1, canvas.clientWidth - 2 * padPx);
      const drawH = Math.max(1, canvas.clientHeight - 2 * padPx);
      const ppm = Math.min(drawW / width, drawH / height);

      const worldCx = (minX + maxX) / 2;
      const worldCy = (minY + maxY) / 2;
      const screenCx = canvas.clientWidth / 2;
      const screenCy = canvas.clientHeight / 2;

      return { ppm, worldCx, worldCy, screenCx, screenCy };
    }

    function worldToScreen(x, y, camera) {
      const sx = camera.screenCx + (x - camera.worldCx) * camera.ppm;
      const sy = camera.screenCy - (y - camera.worldCy) * camera.ppm;
      return [sx, sy];
    }

    function drawLine(p1, p2, color, width, camera) {
      const [x1, y1] = worldToScreen(p1[0], p1[1], camera);
      const [x2, y2] = worldToScreen(p2[0], p2[1], camera);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }

    function worldPointFromRearAxle(cx, cy, yaw, lx, ly) {
      const cosYaw = Math.cos(yaw);
      const sinYaw = Math.sin(yaw);
      return [
        cx + lx * cosYaw - ly * sinYaw,
        cy + lx * sinYaw + ly * cosYaw,
      ];
    }

    function drawCarBody(frame, camera) {
      const { x, y, yaw } = frame.car;
      const vehicle = frame.vehicle ?? {
        wheelbase: 2.7,
        front_overhang: 1.0,
        rear_overhang: 0.95,
        width: 1.65,
      };

      const xRear = -vehicle.rear_overhang;
      const xFront = vehicle.wheelbase + vehicle.front_overhang;
      const halfW = vehicle.width / 2;

      const cornersWorld = [
        worldPointFromRearAxle(x, y, yaw, xRear, -halfW),
        worldPointFromRearAxle(x, y, yaw, xFront, -halfW),
        worldPointFromRearAxle(x, y, yaw, xFront, halfW),
        worldPointFromRearAxle(x, y, yaw, xRear, halfW),
      ];
      const cornersScreen = cornersWorld.map(([px, py]) => worldToScreen(px, py, camera));

      ctx.fillStyle = "rgba(34, 211, 238, 0.28)";
      ctx.strokeStyle = "#22d3ee";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(cornersScreen[0][0], cornersScreen[0][1]);
      for (let i = 1; i < cornersScreen.length; i++) {
        ctx.lineTo(cornersScreen[i][0], cornersScreen[i][1]);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      const rearLeft = worldPointFromRearAxle(x, y, yaw, 0, -halfW * 0.8);
      const rearRight = worldPointFromRearAxle(x, y, yaw, 0, halfW * 0.8);
      drawLine(rearLeft, rearRight, "#e5e7eb", 2, camera);

      const frontAxleLeft = worldPointFromRearAxle(x, y, yaw, vehicle.wheelbase, -halfW * 0.8);
      const frontAxleRight = worldPointFromRearAxle(x, y, yaw, vehicle.wheelbase, halfW * 0.8);
      drawLine(frontAxleLeft, frontAxleRight, "#93c5fd", 2, camera);

      const steerYaw = yaw + frame.car.delta;
      const wheelHalf = 0.45;
      const frontWheelCenter = worldPointFromRearAxle(x, y, yaw, vehicle.wheelbase, 0);
      const wheelA = [
        frontWheelCenter[0] - Math.cos(steerYaw) * wheelHalf,
        frontWheelCenter[1] - Math.sin(steerYaw) * wheelHalf,
      ];
      const wheelB = [
        frontWheelCenter[0] + Math.cos(steerYaw) * wheelHalf,
        frontWheelCenter[1] + Math.sin(steerYaw) * wheelHalf,
      ];
      drawLine(wheelA, wheelB, "#fbbf24", 3, camera);

      const nose = worldPointFromRearAxle(x, y, yaw, xFront, 0);
      const [rx, ry] = worldToScreen(x, y, camera);
      const [nx, ny] = worldToScreen(nose[0], nose[1], camera);
      ctx.strokeStyle = "#e5e7eb";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(rx, ry);
      ctx.lineTo(nx, ny);
      ctx.stroke();

      ctx.fillStyle = "#f59e0b";
      ctx.beginPath();
      ctx.arc(rx, ry, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function draw(frame) {
      ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);
      const map = frame.map_data ?? defaultMap;
      const camera = makeCamera(map);

      map.walls.forEach((w) => drawLine(w.p1, w.p2, "#ef4444", 3, camera));
      drawLine(map.start_line.p1, map.start_line.p2, "#10b981", 2, camera);
      drawLine(map.finish_line.p1, map.finish_line.p2, "#f59e0b", 2, camera);
      drawCarBody(frame, camera);

      episodeEl.textContent = `episode: ${frame.episode}`;
      stepEl.textContent = `step: ${frame.step}`;
      rewardEl.textContent = `reward: ${frame.reward.toFixed(3)} total ${frame.total_reward.toFixed(3)}`;
      eventEl.textContent = `event: ${frame.event ?? "-"}`;
      modeEl.textContent = `mode: ${frame.control_mode ?? "-"}`;
      speedEl.textContent = `speed: ${frame.car.v.toFixed(2)} m/s`;
      steerEl.textContent = `steer: ${(frame.car.delta * 180 / Math.PI).toFixed(1)} deg`;
      document.getElementById("pose-ref").textContent = `pose ref: ${frame.pose_reference ?? "rear_axle_center"}`;
    }

    function sendControl(command) {
      if (ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: "control", command }));
    }

    document.getElementById("btn-step").onclick = () => sendControl("step");
    document.getElementById("btn-pause").onclick = () => sendControl("pause");
    document.getElementById("btn-play").onclick = () => sendControl("play");
    document.getElementById("btn-play-end").onclick = () => sendControl("play_to_end");

    const ws = new WebSocket("ws://127.0.0.1:8765");
    ws.onopen = () => (statusEl.textContent = "status: connected");
    ws.onclose = () => (statusEl.textContent = "status: disconnected");
    ws.onmessage = (ev) => {
      const frame = JSON.parse(ev.data);
      lastFrame = frame;
      draw(frame);
    };
  </script>
</body>
</html>
